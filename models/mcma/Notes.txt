Notes for the python implementation of the MCMA prototype

General assumption:
- two concrete models developed separately in pyomo: core and mc_block,
  integrated (as two blocks into concrete model representing the MMP (as in
  the old C++ implementation).
- crit-specs and persistent data of MC-analysis stored in text file(s);
  data of each analysis instance stored in the corresponding dir.

General structure:
- mcma.py: main function:
  * manages top-level functionality
  * generates the core model
- driver.py:
  * manages flow/iterations
  * interface to persistent data
  * interface to data defining preferences for each iteration
  * aggregates two submodels/blocks
  * runs optimization solver
  * manages optimization results

Main components:
- core model, managed in mcma.py (main py component)i, generated once:
  * preferably its portable (text) representation to be converted into concrete model
  * if the above will not work, then *.py imported (sms+concrete+data for concrete) 
    and the core model generated before integration in mcma.py.
- mc_block: MC part generated (for each preferences) in mc_block.py as concrete model:
  * AF: variable used as maximized goal
  * CAF: variables representing Criterion Achievement Function,
  * constraints linking core_block and mc_block
- helper classes Crit and Mcma (both in crit.py) handling:
  * status/stages of analysis
  * criteria definitions
  * pay-off table
  * specs of preferences and solutions of each iteration: crit-values, A/R

